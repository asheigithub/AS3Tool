{"pages":[{"title":"Categories","date":"2018-03-16T08:34:04.285Z","path":"categories/index.html","text":""},{"title":"关于Apple Juice","date":"2018-03-19T09:54:07.238Z","path":"about/index.html","text":"由于开发目的就是能在IOS上运行，所以起名叫苹果汁。"},{"title":"testpage","date":"2018-03-15T11:33:51.000Z","path":"testpage/index.html","text":""},{"title":"Tags","date":"2018-03-16T08:34:04.286Z","path":"tags/index.html","text":""}],"posts":[{"title":"性能提示","date":"2018-04-11T04:09:29.000Z","path":"2-3-0-performanceintro-2018-04-11/","text":"Apple Juice脚本引擎本身对于结构体和C#的互操作等作了非常多的优化。但是，由于ActionScript3作为一门事实上的动态语言，因此还是有必要注意一些性能优化的注意点。 变量类型：ActionScript3有编译时类型检查功能。如果编译时提供具体的变量类型，则能大幅提高运行性能。因为运行时将无需假设变量的类型，而直接使用最快的执行代码。如果不指定变量类型，则根据规则这个变量是个任意类型的变量。因此运行时将必须在运行时进行类型检查。 函数和对象方法：ActionScript3既可以使用和JS类似的函数，也可用和java类似的对象的方法。区别在于，对象的方法是绑定于对象的，它的this指针无法改变。而函数的this指针却是可以改变的。因此运行时在处理函数（包括匿名函数，闭包等等）的时候，不得不经常重新绑定函数的this。而方法则无此开销。 final的方法：类型的方法如果没有final修饰，同时类型本身也没有被final修饰，则说明它可能被子类覆盖。这样运行时在调用时，将不得不检查实际的对象类型来查找虚方法。如果可以是用final修饰对象，则可以避免虚方法查找。 dynamic的类型：用dynamic修饰的类型，可以在运行时动态的增加，删除对象的成员。但是代价就是更多的内存开销和较慢的执行速度，因为运行时将不得不动态查找成员。 prototype原型链：ActionScript3作为EcmaScript4,确实支持原型链系统。原型链可以动态的给类型的所有实例动态的添加方法和成员，但是同样的，原型链将导致运行时必须到原型链中进行查找，引起性能降低。 纵上所述，尽量避免使用方便的动态语言特性，使用强类型和类继承系统。最后最重要的一点，鉴于脚本引擎无论如何不可能达到C#宿主的性能，因此，将不会改变的部分放在C#中，导出为API是最好的选择。","tags":[],"categories":[{"name":"2_advuse","slug":"2-advuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/2-advuse/"},{"name":"2_3performance","slug":"2-advuse/2-3performance","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/2-advuse/2-3performance/"}]},{"title":"继承的原理","date":"2018-04-10T10:03:37.000Z","path":"2-1-9-extendsprinciple-2018-04-10/","text":"Apple Juice允许您在ActionScript3中继承并扩展C#的基类。这个特性通过以下方式实现： 当导出API时，当导出工具发现某个类型可以被脚本继承时，将会自动创建一个这个类型的适配器类型。此适配器类型继承自此类型，并且还可以和脚本交互。作为一个桥梁的形式存在。 当ActionScript3引擎创建脚本中继承基类的对象时，实际上同时创建了这个适配器和AS3脚本对象两个对象。这两个对象互相绑定，当传给.net系统时，实际上是用的是这个适配器，当在脚本系统中使用时，则是操作AS3脚本对象。 Apple Juice代码中定义了如下接口： 1234567891011/// &lt;summary&gt;/// 标记这是一个可以跨脚本语言继承的对象/// &lt;/summary&gt;public interface ICrossExtendAdapter&#123; void SetAS3RuntimeEnvironment(Player player, ASBinCode.rtti.Class typeclass, ASBinCode.rtData.rtObjectBase bindAS3Object); ASBinCode.rtti.Class AS3Class &#123; get; &#125; ASBinCode.rtData.rtObjectBase AS3Object &#123; get; &#125;&#125; 所有适配器都会实现这个接口。当ActionScript3引擎创建适配器实例后，会调用SetAS3RuntimeEnvironment方法，将对应的AS3脚本对象以及脚本引擎传入进来。此适配器会保存它们，以备交互时使用。 适配器能覆盖基类的方法，然后适配器又能和脚本交互，以决定具体使用哪个版本的方法。 实例说明以上一章的Shape为例，来具体讲解这个适配器是如何起作用的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class extendtest_ShapeAdapter :extendtest.Shape ,ASRuntime.ICrossExtendAdapter&#123; public ASBinCode.rtti.Class AS3Class &#123; get &#123; return typeclass; &#125; &#125; public ASBinCode.rtData.rtObjectBase AS3Object &#123; get &#123; return bindAS3Object; &#125; &#125; protected Player player; private Class typeclass; private ASBinCode.rtData.rtObjectBase bindAS3Object; public void SetAS3RuntimeEnvironment(Player player, Class typeclass, ASBinCode.rtData.rtObjectBase bindAS3Object) &#123; this.player = player; this.typeclass = typeclass; this.bindAS3Object = bindAS3Object; &#125; public extendtest_ShapeAdapter():base()&#123;&#125; private ASBinCode.rtData.rtFunction _as3function_0; private int _as3functionId_0 =-1; public override System.Double area() &#123; if (_as3function_0 == null) _as3function_0 = (ASBinCode.rtData.rtFunction)player.getMethod(bindAS3Object, \"area\"); if (_as3functionId_0 == -1) &#123; _as3functionId_0 = ((ClassMethodGetter)typeclass.getBaseLinkSystemClass().classMembers.FindByName(\"area\").bindField).functionId; &#125; if (_as3function_0 != null &amp;&amp; (player == null || (player != null &amp;&amp; NativeConstParameterFunction.checkToken( new NativeConstParameterFunction.ExecuteToken( player.ExecuteToken.tokenid, _as3functionId_0 ) )) ) ) &#123; return base.area(); &#125; else &#123; return (System.Double)player.InvokeFunction(_as3function_0,0,null,null,null,null,null,null); &#125; &#125;&#125; 这个extendtest_ShapeAdapter，继承自extendtest.Shape,同时实现了ASRuntime.ICrossExtendAdapter接口。 player 成员保存播放器对象 typeclass 成员保存ActionScript3对象的Class bindAS3Object 成员保存ActionScript3对象。 extendtest_ShapeAdapter覆盖extendtest.Shape的area方法。这个方法作为调用的桥梁。它判断究竟要调用脚本中的覆盖的方法还是调用基类的方法。当此方法第一次执行时，首先查找脚本中的子类中的对应方法。如果没有找到，则直接调用基类的方法。 如果此方法是被脚本引擎调用的，则有可能是脚本中调用了基类的方法。脚本引擎在每次调用本地对象前，都会发出一个令牌。在这种情况下，先检测令牌是否匹配，如果匹配，则调用父类的方法。 如果此方法是被C#代码调用的，如果子类中有对应的方法。则调用脚本引擎，执行子类中覆盖的方法。 如果是由C#代码发起调用，脚本引擎执行子类方法，子类又调用父类方法时，则令牌生效，这样即可正确判断使用父类版本或者脚本覆盖版本。","tags":[],"categories":[{"name":"2_advuse","slug":"2-advuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/2-advuse/"},{"name":"2_2adv","slug":"2-advuse/2-2adv","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/2-advuse/2-2adv/"}]},{"title":"关于MonoBehaviour","date":"2018-04-10T09:54:32.000Z","path":"2-2-0-monobehaviour-2018-04-10/","text":"上一章描述的脚本继承，可以自动处理那些用new关键字在脚本中创建实例的情况。但是，某些类型却无法使用new关键字创建，它们或者需要某些工厂方法创建，或者使用new关键字会报错。Unity中，这样的典型对象有Component类型。MonoBehaviour是其中的典型，它必须使用GameObject.AddComponent等方法创建。本章描述如何处理这种情况。代码创建工具会帮我们创建好GameObject.AddComponent的API的大部分代码。并且已经注册到脚本引擎中。我只需将它拷贝一份出来，在它基础上进行一些修改，然后覆盖之前注册的代码即可。使用CSWC对象的regNativeFunction(NativeFunctionBase nativefunction, bool isReplace)方法注册本地代码，并且可以指定是否覆盖。 处理Component 首先我们到自动生成的API代码中，找到 unityengine_GameObject_buildin 这个类。这个类内定义了unityengine_GameObject_addComponent嵌套类。这个嵌套类就是GameObject.AddComponet的API代码。 我们新建一个叫GameObject_addComponent的类，然后将unityengine_GameObject_addComponent的代码拷贝到新的类型里去，并修改错误。 execute3方法，就是实际调用GameObject.AddComponent的地方。我们在AddComponent调用后，如果生成的对象是一个适配器对象，则继续完成适配器的初始化工作。只需在后面添加如下代码即可: 123456ICrossExtendAdapter crossExtendAdapter = _result_ as ICrossExtendAdapter;if (crossExtendAdapter != null)&#123; ASBinCode.rtti.Class as3class = ((ASBinCode.rtData.rtObjectBase)argements[0]).value._class; stackframe.player.MakeICrossExtendAdapterEnvironment(crossExtendAdapter, as3class);&#125; 将此方法注册到脚本引擎中。 这样，即可正确生成可在脚本中使用的Component类型。 处理MonoBehaviourMonoBehaviour是Component的子类。因此，经过以上处理，已经可以通过脚本挂载从脚本中定义的MonoBehaviour子类。但是，MonoBehaviour非常特殊，Unity会根据MonoBehaviour中是否定义有例如Update等方法来根据实际调用这些方法。这些方法不是virtual的，因此MonoBehaviour的适配器也需要特殊处理。 如前那样，从自动生成的代码中找到unityengine_MonoBehaviour_buildin，然后找到unityengine_MonoBehaviourAdapter和_unityengine_MonoBehaviourAdapter_ctor，将他们的代码复制到新建的类型里去。 MonoBehaviourAdapter_ctor 中有new MonoBehaviourAdapter() 的操作，将它删除，因为MonoBehaviour不会通过new创建 修改MonoBehaviourAdapter的代码。在里面定义Update方法，然后将它转发到脚本系统中。代码如下: 1234567891011121314private ASBinCode.rtData.rtFunction _Update;private bool _Update_hasfound;private void Update()&#123; if (!_Update_hasfound) &#123; _Update = (ASBinCode.rtData.rtFunction)player.getMethod(bindAS3Object, \"Update\"); _Update_hasfound = true; &#125; if (_Update == null) return; player.InvokeFunction(_Update, 0, null, null, null, null, null, null);&#125; 将代码注册到系统中。 如此，在脚本中定义的MonoBehaviour即可正确处理Update。 其他Apple Juice系统自带脚本中已经处理好常用MonoBehaviour的情况，包括AddComponent,GetComponent系列等，有些MonoBehaviour事件未实现，例如OnAnimatorIK等等，如果有需要，可以仿照实现。这部分代码在GObj_Special中。 在脚本中可以执行SendMessage，给自定义的MonoBehaviour发送消息。这部分系统已处理，但是，无法从C#给脚本中定义的MonoBehaviour子类用SendMessage发送消息。因为MonoBehaviourAdapter中，不可能预知会有哪些方法名，因此，C#中直接用SendMessage是无法调用脚本中的方法的。如果确实需要，则需要调用MonoBehaviourAdapter中的internal bool F6554FF96D0D340948D3DCD4AA9225CCD(string arg0, object arg1, SendMessageOptions arg2)方法。其中arg0是方法名，arg1是参数。这是MonoBehaviourAdapter处理脚本中SendMessage的方法。可以直接通过它发送消息","tags":[],"categories":[{"name":"2_advuse","slug":"2-advuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/2-advuse/"},{"name":"2_2adv","slug":"2-advuse/2-2adv","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/2-advuse/2-2adv/"}]},{"title":"进阶概述","date":"2018-03-28T09:05:16.000Z","path":"2-0-0-advoverview-2018-03-28/","text":"除了基本使用，Apple Juice脚本系统还提供了更多的扩展。例如，可以从脚本中继承Unity中定义的类库，并且还可以扩充它的属性，甚至还可以使用override，重新定义基类的某些行为，无论基类是ActionScript3中定义的，还是用C#定义的。 在绝大多数情况下，脚本的执行效率总是不如宿主的效率。因此我们可以将一些基础功能制作成类库，放在宿主中以获得最高的执行效率。除了其他常规脚本系统的常见方式外，Apple Juice可以将宿主中的类当作ActionScript3的基类，使用继承与多态来获得更灵活的交互。 Apple Juice是以代码形式提供的插件，因此您还可扩充它的功能，比如自定义内置函数，或者定制API的导出代码等等。本章节会讨论这些内容。","tags":[],"categories":[{"name":"2_advuse","slug":"2-advuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/2-advuse/"}]},{"title":"脚本继承","date":"2018-03-28T09:01:19.000Z","path":"2-1-0-extends-2018-03-28/","text":"继承继承是指一种代码重用的形式，允许基于现有类开发新类。现有类通常称为基类 或超类，新类通常称为子类。继承的主要优势是，允许重复使用基类中的代码，但不修改现有代码。此外，继承不要求改变其它类与基类交互的方式。不必修改可能已经过彻底测试或可能已被使用的现有类，使用继承可将该类视为一个集成模块，可使用其它属性或方法对它进行扩展。因此，您使用 extends 关键字指明类从另一类继承。通过继承还可以在代码中利用多态。有一种方法在应用于不同数据类型时会有不同行为，多态就是对这样的方法应用一个方法名的能力。 如前所述，我们可以在宿主(Unity)工程中定义基类，然后在脚本中扩展它或者修改它。我们在Unity中定义一个名为 Shape 的基类就是一个简单的示例，该类有名为 Circle 和 Square 的两个子类。Shape 类定义了名为 area() 的方法，该方法返回形状的面积。如果已实现多态，则可以对 Circle 和 Square 类型的对象调用 area() 方法，然后执行正确的计算。使用继承能实现多态，实现的方式是允许子类继承和重新定义或覆盖 基类中的方法。我们可以在宿主工程中创建Circle类，在ActionScript3工程中创建Square类。 打开Unity工程，在Assets目录中创建一个C#脚本。 将如下代码写入脚本中。 1234567891011121314151617181920212223242526using System.Collections;using System.Collections.Generic;using UnityEngine;namespace extendtest&#123; public class Shape &#123; public virtual double area() &#123; return double.NaN; &#125; &#125; public class Circle : Shape &#123; private double radius = 1; public override double area() &#123; return (Mathf.PI * (radius * radius)); &#125; &#125;&#125; 打开ActionScript3工程，使用bat/CreateUnityAPI.bat将刚才写的代码导出API。 打开Main.as。在Main.as底部，最后一个}后面写下如下代码:1234567891011121314151617import extendtest.Circle;import extendtest.Shape;//我们在ActionScript3中继承Shape,并且覆盖它的area方法。class Square extends Shape &#123; private var side:Number = 1; override public function area():Number &#123; return (side * side); &#125; &#125; var cir:Circle = new Circle(); trace(\"Circele:\",cir.area()); // output: 3.141592653589793 var sq:Square = new Square(); trace(\"Square:\", sq.area()); // output: 1 由于某些未知原因，在Unity工程中定义的类型，如果使用 abstract 定义为抽象类，导出工具在分析Assembly-CSharp.dll时，无非正确的得到它是抽象类这个信息。因此，不要在Unity工程中用抽象类定义API。 点击编译。将代码发布到Unity。 在Unity总执行场景，可以看到运行结果。其中，Circele是在Unity中定义，而Shape却是在脚本中定义的。 在Main.as底部，包体的外部写下代码，在ActionScript3中称为包外代码，在这里定义的类型叫包外类。这些代码会在Main第一次被实例化前被调用。在这里添加代码是一个方便的测试方式，Apple Juice也同样实现了这个ActionScript3的语言特性。 特殊情况某些类型没有构造函数，或者它们的使用方式比较特殊，是使用某种类似工厂的方法创建的。最典型的例子就是MonoBehaviour。对于这些特殊的类型，如果要在脚本中继承，则还需要一些额外的处理。后面的章节将讲述原理和解决方法。","tags":[],"categories":[{"name":"2_advuse","slug":"2-advuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/2-advuse/"},{"name":"2_2adv","slug":"2-advuse/2-2adv","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/2-advuse/2-2adv/"}]},{"title":"Demo工程介绍","date":"2018-03-27T07:49:37.000Z","path":"1-9-2-unitydemointro-2018-03-27/","text":"Unity部分打开HotFixDemoScene1.scene场景，就能看到示例工程。本示例工程介绍了怎样使用ActionScript3执行逻辑。总体而言，要在Unity项目中执行ActionScript3,需要以下几个步骤： 创建ActionScript3运行时。 加载ActionScript3字节码。 创建ActionScript3的入口对象。 调用 或者每帧都调用一次刚才创建的ActionScript3对象的某个方法。 创建ActionScript3运行时首先需要创建一个ActionScript3的虚拟机。这个虚拟机可以实际执行ActionScript3代码。一般来说全局只需要一个，在任意需要执行ActionScrip3的地方都调用这个虚拟机来执行。有两种方案，一种是将虚拟机保存在一个全局静态变量中，另一种是创建一个GameObject,使它一直存在于场景中。在这个GameObject上附加一个MonoBehaviour,让这个MonoBehaviour承载虚拟机。 可随时用GameObject.Find()来访问。本Demo工程选用第二种方案。在场景中有一个名叫AS3Player的GameObject。在下面挂载了ActionScriptStartUp.cs。ActionScriptStartUp是一个Monobehaviour。如前所述，此Monobehaviour承载了运行时，并且每帧都会调用ActionScript3的方法，以驱动逻辑更新。 以下代码可创建AS3运行时。1var flashplayer = new ASRuntime.Player(); 以下代码用以从二进制字节数组中加载as3代码。 1234567891011121314151617#if UNITY_ANDROID WWW www = new WWW(Application.streamingAssetsPath + \"/hotfix.cswc\");#else WWW www = new WWW(\"file:///\" + Application.streamingAssetsPath + \"/hotfix.cswc\");#endif while (!www.isDone) yield return null; if (!string.IsNullOrEmpty(www.error)) UnityEngine.Debug.LogError(www.error); //加载as3编译器生成的字节码。 //Loads the byte code generated by the compiler. ASBinCode.CSWC swc = ASBinCode.CSWC.loadFromBytes(www.bytes); www.Dispose(); ASRuntime.nativefuncs.BuildInFunctionLoader.loadBuildInFunctions(swc); 字节码可以保存在任意地方，您也可以从网络下载字节码。 以下代码开始加载API代码。由于可能导出了大量的API函数，因此加载时可以试用进度条。使用协程功能，可以避免卡顿，和监测加载进度。 12345678910111213//**注册本地代码有可能非常之多。所以提供了一个进度条** //API code can be very much. So a progress bar is provided int functioncount = 0; while (regenumerator.MoveNext()) &#123; functioncount++; if (functioncount % 50 == 0) &#123; progress.value = extfunctions.progress; progressValue.text = \"loading:\" + extfunctions.progress * 100 + \"%\"; yield return null; &#125; &#125; 最后，需要让运行时加载二进制字节码，用以下代码进行加载: 1flashplayer.loadCode(swc); 当运行时加载完成字节码后，即可调用运行时的一些方法，来对ActionScript3代码进行操作。例如，createInstance()可用来创建一个ActionScript3对象，getMethod则可以访问对象的某个方法，等等。我们创建 Main.as 的一个对象实例，然后找到它的update方法，并保存起来。每帧都执行一次此实例的update方法，即可推动逻辑更新。 12main = flashplayer.createInstance(\"Main\");updatemethod= flashplayer.getMethod(main, \"update\"); 在MonoBehaviour的Update()方法中，调用运行时驱动ActionScript3代码。 123456void Update () &#123; if (player != null) &#123; player.invokeMethod(main, updatemethod); &#125;&#125; ActionScript3部分现在我们来看ActionScript3部分的代码。本Demo的逻辑功能都定义在Main类中。当上面创建Main的实例时，构造函数将会被调用。构造函数中，创建了100个立方体到场景中。然后，给场景中的按钮追加事件处理函数。 1234567891011121314151617181920212223242526var cube:UObject = GameObject.find(\"Cube\");for (var i:int = 0; i &lt; 100; i++) &#123; var c2:GameObject = GameObject.createPrimitive( PrimitiveType.Cube); //UObject.instantiate__(cube) as GameObject; MeshRenderer( c2.getComponent(MeshRenderer)).material = MeshRenderer( GameObject( cube).getComponent(MeshRenderer)).material; c2.transform.position = new Vector3( Random.range(-5,5),Random.range(0,5),Random.range(-5,5) ); cubes.push(c2); mvs.push( new Vector3(Random.range( -5, 5), Random.range(-5, 5), Random.range( -5, 5)) ); mvs[mvs.length - 1].normalize(); //if (i &gt; 10) //&#123; //c2.setActive(false); // //&#125; &#125;var btn:Button = Button( GameObject.find(\"Button\").getComponent(Button)); btn.onClick.addListener( onclick ); Main类有实例方法update。在Unity工程中，每帧都会驱动此方法，这个方法更新立方体们的位置。 1234567891011121314151617181920212223242526public function update():void&#123; if (isstop) return; for (var i:int = 0; i &lt; 100; i++) &#123; var cube:GameObject = cubes[i]; var v:Vector3 = mvs[i]; var vv:Vector3 = new Vector3(4, 5, 6); cube.transform.localPosition += v * Time.deltaTime; var p:Vector3 = cube.transform.localPosition; if (p.x &lt;-5 || p.y &lt; -5 || p.z &lt; -5 || p.x &gt; 5 || p.y &gt; 5 || p.z &gt; 5) &#123; mvs[i] =-mvs[i]; &#125; //var k:NavMesh; //k = cube; &#125; &#125; 您可以点击场景中的按钮，观察事件的处理。 update方法中，可以看到使用了大量的new Vector3操作。由于Vector3是一个结构体。在C#中，方法内部new结构体不会导致GC。Apple Juice 脚本引擎同样实现了这个效果，因此，update代码是不会导致内存分配的。","tags":[],"categories":[{"name":"1_beginuse","slug":"1-beginuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/"},{"name":"1_3unityproj","slug":"1-beginuse/1-3unityproj","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/1-3unityproj/"}]},{"title":"Apple Juice Unity插件","date":"2018-03-21T11:40:02.000Z","path":"1-9-1-unityplugin-2018-03-21/","text":"Apple Juice 的Unity插件包提供了创建ActionScript3工程的功能以及其他一些功能，包括 清除已生成的API代码 打开ActionScript3项目所在目录 它在Unity中生成了一个顶级菜单”ASRuntime”,其他功能都在子菜单中。 Set up the ASRuntime SDK在工程中指定Applie Juice的SDK所在的路径。 Create ActionScript3 FlashDevelop HotFixProject创建ActionScript3脚本工程。 Open ActionScript3 Project Folder如果成功创建了脚本工程，或者打开过一次脚本工程所在目录，则可以记住上次打开的路径，为您打开脚本工程所在目录。 Clean API Code清除所有生成的API代码。如果这样做了，可以再次在脚本工程中重新生成。","tags":[],"categories":[{"name":"1_beginuse","slug":"1-beginuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/"},{"name":"1_3unityproj","slug":"1-beginuse/1-3unityproj","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/1-3unityproj/"}]},{"title":"内容说明","date":"2018-03-21T10:52:28.000Z","path":"1-9-0-useunityproj-2018-03-21/","text":"当插件导入后，Unity的工程目录为: Assets├────── ASRuntimePlayer│ ├─────Editor│ │ ├──── ASRuntimeMenus.cs│ │ └──── ASRuntimeSettings.cs│ ├─────RegCode│ ├─────Support│ │ └──── extFunctions.cs│ └─────ActionScriptStartUp.cs├────── Standard Assets│ └─────ASRuntime│ ├──── AS3VM│ └──── ScriptSupport│ └──── Generated├────── StreamingAssets│ └─────hotfix.cswc├────── HotFixDemoScene1.unity└────── link.xml HotFixDemoScene1.unityDemo示例场景。 hotfix.cswcActionScript3脚本编译后生成的二进制字节码文件。 ASRuntimePlayer/EditorUnity插件代码目录。 ASRuntimePlayer/RegCode包含如下2类文件： 生成API时，自动生成的一个注册所有API函数的代码文件。 那些在Unity工程中并且不在Standard Assets目录中定义的类库，当导出API代码时，将会生成到这个目录下。 Standard Assets/ASRuntime/ScriptSupport/Generated自动导出的API代码将会生成到这里。 Unity会自动编译工程目录中的代码。在Standard Assets目录下的代码会首先被编译，生成一个Assembly-CSharp-firstpass.dll。其他目录下的代码将编译生成一个Assembly-CSharp.dll。Standard Assets目录下的代码，无法引用其他目录下的代码。如果在Standard Assets 目录中保存导出的API,则可以避免API频繁的编译，因为这部分代码是不经常变动的。虽然导出的API可能很多，编译速度慢，但是放在这个目录下，只需编译一次，不会经常改变。因此将Unity工程内自定义的类库导出的API放在“ASRuntimePlayer/RegCode”中，其他API放在Standard Assets/ASRuntime/ScriptSupport/Generated中，可以保证生成代码的引用关系正确，并且UnityEngine.dll导出的API不会频繁编译。 link.xmlUnity在使用IL2CPP发布时，比如发布IOS包或者安卓选择IL2CPP发布时，会自动对Unity工程的DLL进行裁剪，将代码中没有引用到的类型裁剪掉，以达到减小发布后包体大小的目的。然而在实际使用过程中，很多类型可能被异常裁剪掉。link.xml可以配置哪些类型不会被裁剪。Apple Juice 自动生成的API代码都在Assembly-CSharp-firstpass.dll或者Assembly-CSharp.dll中，因此，link.xml里默认配置了如下几处程序集不会被裁剪。如无意外，可不必修改此文件。如果您有其他的Dll库文件导出了API,那么您可以将此DLL的程序集配置到此文件中。1234567&lt;linker&gt; &lt;assembly fullname=\"Assembly-CSharp\" preserve=\"all\"/&gt; &lt;assembly fullname=\"Assembly-CSharp-firstpass\" preserve=\"all\"/&gt; &lt;assembly fullname=\"UnityEngine\" preserve=\"all\"/&gt; &lt;assembly fullname=\"UnityEngine.UI\" preserve=\"all\"/&gt; &lt;assembly fullname=\"mscorlib\" preserve=\"all\"/&gt;&lt;/linker&gt;","tags":[],"categories":[{"name":"1_beginuse","slug":"1-beginuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/"},{"name":"1_3unityproj","slug":"1-beginuse/1-3unityproj","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/1-3unityproj/"}]},{"title":"使用自定义API","date":"2018-03-21T09:27:43.000Z","path":"1-8-0-customapi-2018-03-21/","text":"您也可以在Unity工程中创建您自己的API代码。SDK中的工具LinkCodeGen.exe同样能将您自定义的类库导出为可与ActionScript3交互的API。再次说明要注意的是，只有Public的类型，并且处在某个命名空间下的类型才会被导出，否则是不会导出的。 自定义API示例以下步骤演示如何自定义一个类库。 打开Unity工程，在Assets目录下，右键菜单 “Create/C# Script”,创建一个TestAPI的脚本。 将TestAPI.cs的内容改为如下代码: 123456789101112131415using System.Collections;using System.Collections.Generic;using UnityEngine;namespace myapi&#123; public class TestAPI &#123; public int AddTest(int a, int b) &#123; return a + b; &#125; &#125;&#125; 打开ActionScript3项目所在文件夹。(可点击菜单 “ASRuntime/Open ActionScript3 Project Folder” 来打开) 用FlashDevelop打开ActionScript3项目。 找到 “bat/CreateUnityAPI.bat”,单机右键，从弹出菜单中选择执行。等待API生成完毕。 打开Main.as，找到第100行左右的 onclick 方法。将它改为如下代码: 123456789101112131415private function onclick()&#123; var testAPI:TestAPI = new TestAPI(); Text( GameObject.find(\"Canvas/Text\").getComponent(Text)).text = \"100+50\" + testAPI.addTest(100, 50); //isstop = !isstop; //trace(\"isstop?\" , isstop); // //Text( GameObject.find(\"Canvas/Text\").getComponent(Text)).text = \"isstop?\" + isstop // //+\"我在AS3中热更\" //; &#125; 点击编译。 回到Unity,点击运行，然后点击按钮，即可看到我们的API被成功调用了。","tags":[],"categories":[{"name":"1_beginuse","slug":"1-beginuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/"},{"name":"1_2useas3","slug":"1-beginuse/1-2useas3","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/1-2useas3/"}]},{"title":".net API的导出","date":"2018-03-20T12:04:22.000Z","path":"1-7-0-exportapi-2018-03-20/","text":".net API可以由SDK中的工具LinkCodeGen.exe进行导出。但是由于语言限制，某些类型是无法被导出的。 不能被导出的类型 不在任何命名空间下的类型不会被导出。 标记为System.ObsoleteAttribute的类型。这些类型被标记为过时的，有可能导致编译失败。因此，工具检查到这样的类型或成员时，将不会导出. System.Type类型。 System.Type类型和ActionScript3的Class有特殊关联,System.Type类型本身不会被导出。 非公开的类型和成员不会被导出。只有Public的类型才能导出。 泛型定义类型不会被导出。但是如果.net类库中有泛型类型，这个泛型类型是可以被导出的。例如 List&lt;T&gt; 本身是不会被导出的，但是如果.net类库中有List&lt;String&gt; 这样的类型，则List&lt;String&gt;会被自动处理。 如果某个类型继承自不可导出的类型，那么它也同样不能导出。 不能被导出的成员 非公开的成员不会被导出。 如果某个方法的参数或者返回值是不能导出的类型，则它不会被导出。 如果某个成员被标记为System.ObsoleteAttribute的，则它不会被导出。 如果某个方法是泛型定义方法，则它不会被导出。但是泛型方法是可以被导出的。例如 MonoBehaviour.GetComponent,这个方法不会被导出。但是如果某个类型继承了MonoBehaviour,又定义了 GetComponent,则这个方法是可以被导出的。 导出时的特殊处理 泛型类型导出时，名字改为 &lt;TypeName&gt; _Of_ &lt;GenericType&gt;。例如 1UnityEngine.Events.UnityAction&lt;System.Boolean&gt; 将导出为123public final class UnityAction_Of_Boolean extends system.MulticastDelegate implements system.ICloneable&#123;&#125; 方法重载。.net支持重载，ActionScript3则不支持重载。因此，当遇到这样的情况时，工具将会在重载的函数后面加上一个下划线_。例如，System.DateTime.GetDateTimeFormats有若干重载，则会导出为如下API: 1234567891011121314151617181920212223242526272829303132333435363738/*** System.DateTime.GetDateTimeFormats*return:* System.String[]*/[native,system_DateTime_getDateTimeFormats];public final function getDateTimeFormats():_Array_;/*** System.DateTime.GetDateTimeFormats*parameters:* provider : System.IFormatProvider*return:* System.String[]*/[native,system_DateTime_getDateTimeFormats_];public final function getDateTimeFormats_(provider:IFormatProvider):_Array_;/*** System.DateTime.GetDateTimeFormats*parameters:* format : System.Char*return:* System.String[]*/[native,system_DateTime_getDateTimeFormats__];public final function getDateTimeFormats__(format:Char):_Array_;/*** System.DateTime.GetDateTimeFormats*parameters:* format : System.Char* provider : System.IFormatProvider*return:* System.String[]*/[native,system_DateTime_getDateTimeFormats___];public final function getDateTimeFormats___(format:Char,provider:IFormatProvider):_Array_; 如果是构造函数重载，则保留找到的第一个构造函数，其他构造函数改名为constructor_。若有多个重载，则追加下划线。例如System.DateTime有许多构造函数，则导出为: 123456789101112131415161718192021222324252627282930313233//*********构造函数*******[native,system_DateTime_constructor_];public static function constructor_(ticks:Int64,kind:DateTimeKind):DateTime;[native,system_DateTime_constructor__];public static function constructor__(year:int,month:int,day:int):DateTime;[native,system_DateTime_constructor___];public static function constructor___(year:int,month:int,day:int,calendar:system.globalization.Calendar):DateTime;[native,system_DateTime_constructor____];public static function constructor____(year:int,month:int,day:int,hour:int,minute:int,second:int):DateTime;[native,system_DateTime_constructor_____];public static function constructor_____(year:int,month:int,day:int,hour:int,minute:int,second:int,kind:DateTimeKind):DateTime;[native,system_DateTime_constructor______];public static function constructor______(year:int,month:int,day:int,hour:int,minute:int,second:int,calendar:system.globalization.Calendar):DateTime;[native,system_DateTime_constructor_______];public static function constructor_______(year:int,month:int,day:int,hour:int,minute:int,second:int,millisecond:int):DateTime;[native,system_DateTime_constructor________];public static function constructor________(year:int,month:int,day:int,hour:int,minute:int,second:int,millisecond:int,kind:DateTimeKind):DateTime;[native,system_DateTime_constructor_________];public static function constructor_________(year:int,month:int,day:int,hour:int,minute:int,second:int,millisecond:int,calendar:system.globalization.Calendar):DateTime;[native,system_DateTime_constructor__________];public static function constructor__________(year:int,month:int,day:int,hour:int,minute:int,second:int,millisecond:int,calendar:system.globalization.Calendar,kind:DateTimeKind):DateTime;[native,system_DateTime_ctor];public function DateTime(ticks:Int64); 操作符重载。 .net支持操作符重载。对于这样的类型，导出后同样保留了可用的操作符重载。例如System.Decimal,导出后保留了各种操作符重载，在脚本中同样可用。 123456789/** * 计算 d1 % d2 */[native,static_system_Decimal_op_Modulus];public static function op_Modulus(d1:Decimal,d2:Decimal):Decimal;[operator,\"%\"];[native,static_system_Decimal_op_Modulus];private static function _operator_op_Modulus(d1:Decimal,d2:Decimal):Decimal; 如下代码1234var d1:Decimal = new Decimal(77);var d2:Decimal = new Decimal(65);trace(\"d1 % d2 =\",d1 % d2); 执行结果1d1 % d2 = 12 委托的操作符重载有 +和-。因此+=和-=是可用的。但是需要注意一点，如果委托变量为null,则不能直接使用+=,必须使用=进行赋值。当变量不为null时，可用+=,-=来操作多路委托。","tags":[],"categories":[{"name":"1_beginuse","slug":"1-beginuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/"},{"name":"1_2useas3","slug":"1-beginuse/1-2useas3","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/1-2useas3/"}]},{"title":"新增语言特性","date":"2018-03-20T10:29:36.000Z","path":"1-6-0-newfeature-2018-03-20/","text":"为了更好的和.net之间互相调用，ActionScript3系统新增了一些语言特性。 枚举器接口这个功能是Apple Juice系统新增的。 接口定义如下枚举器接口是内置的:123456789101112131415161718package system.collections &#123; /** * ... * @author */ [_IEnumerator_] public interface IEnumerator &#123; function get current():*; function moveNext():Boolean; function reset():void; &#125; &#125; 凡是实现此接口的对象都可用for each 或者 for in 语法遍历。 yield系统新增加了一个关键字:yield。它可用自动将一个function的返回值包装成为Ienumerator接口。见如下代码 123456789101112var functionEnumerator = function(count:int)&#123; for (var j:int = 0; j &lt; count; j++) &#123; yield return j; &#125; &#125;for each (var k in functionEnumerator(5)) &#123; trace(\"k:\", k);&#125; 输出:12345k: 0k: 1k: 2k: 3k: 4 枚举器转换Apple Juice在.net部分定义了一个Iterator类型。这个类型本身实现了System.Collections.IEnumerator接口，同时又可以操作ActionScript3脚本的枚举器接口。因此，可以作为ActionScript3和.net之间的枚举器的桥梁。使用ActionScript3的强制类型转换语法 Iterator()，将脚本对象包装成.net对象。当.net类库需要接收System.Collections.IEnumerator接口时，可以用它来包装脚本。 典型的使用场合：Unity中使用协程时，可以直接在脚本中定义IEnumerator对象，然后用Iterator包装后传给Unity。参加如下代码：先使用GameObject.find找到MonoBehaviour对象，然后用MonoBehaviour的startCoroutine方法启动一个协程。这个协程可以直接在脚本中定义。 12345678910111213141516171819var mono:MonoBehaviour = GameObject.find(\"AS3Player\").getComponent(MonoBehaviour) as MonoBehaviour;trace(mono.name);mono.startCoroutine( Iterator( ( function() &#123; trace(\"a\",Time.frameCount); yield return 1; trace(\"b\",Time.frameCount); yield return 2; trace(\"c\",Time.frameCount); yield return 3; &#125; )())); 结构体.net类库中，既有值类型也有引用类型。结构体是值类型。.net中，直接基于值类型的变量包含值。 将一个值类型变量分配给另一个值类型变量将复制包含的值。 这不同于分配引用类型变量，后者复制对对象的引用，但不复制对象本身。绝大多数脚本语言都没有值类型，只有引用类型。因此，Apple Juice新增了对值类型的处理。 值类型不能在脚本中定义，但是如果.net类库中的某个类型是值类型，那么导入后它保持了值类型的特性。 在Apple Juice ActionScript3中,如果将一个值类型的变量赋值给另一个变量，那么将会把变量的值复制给另一个变量。 未赋值的值类型变量默认值为null。 综上，值类型导入脚本后，相当于.net中的System.Nullable类型 见如下代码:123456789var v1:Vector3 = new Vector3(0, 0, 100);var v2:Vector3;trace(\"v2:\",v2);v2 = v1;trace(\"v2:\",v2);v2.z = 999;trace(\"v2:\",v2,\"v1:\",v1); 123456//v2未赋值，默认为nullv2: null//v2的值从v1复制过来v2: (0.0, 0.0, 100.0)//由于v2的值是复制得来的，改变并未对v1造成影响。v2: (0.0, 0.0, 999.0) v1: (0.0, 0.0, 100.0)","tags":[],"categories":[{"name":"1_beginuse","slug":"1-beginuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/"},{"name":"1_2useas3","slug":"1-beginuse/1-2useas3","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/1-2useas3/"}]},{"title":"类型转换","date":"2018-03-20T08:43:01.000Z","path":"1-5-0-useactionscript-2018-03-20/","text":"基本类型ActionScript3内置有一些数据类型。当调用.net类库时，脚本系统会自动将它们进行转换成.net的相应类型传递给.net类库。当.net类库返回值时，脚本系统也会将它转换为ActionScript3类型。下面说明了基础类型的转换: Boolean对应C#的bool。 int对应C#的int。 当.net类库需要接收short时，系统会自动转换为short。当.net类库返回short时，系统会自动转换回 ActionScript3的int。 uint对应C#的uint。 当.net类库需要接收ushort时，系统会自动转换为ushort。当.net类库返回ushort时，系统会自动转换回 ActionScript3的uint。 Number对应C#的double。 当.net类库需要接收float时，系统会自动转换为float。当.net类库返回float时，系统会自动转换回 ActionScript3的Number。 String对应C#的string。 保留类型ActionScript3语言中有些类型是ActionScript3特有的。它们不能被转换成.net的类型。 ArrayActionScript3中的Array是特殊的。他事实上是一个键值对类型，并非其他编程语言的数组。因此，Array只在脚本内部使用。.net的数组被作为API导入到脚本系统内。.net的System.Array的各种方法都被导入，可用于操作.net数组。 ObjectActionScript3中的Object是ActionScript3类型的基类。导入的.net的类库的基类是.net中的System.Object。System.Object导入到ActionScript3中成为 system.Object,同样也继承自ActionScript3的Object。 当调用.net类库时，如果是导入的类型，系统会自动转换成.net类型，否则将会发生类型错误。当.net类库返回某个类型的值时，如果是这个类型导出过API，则系统能自动识别并在脚本中使用，否则将导致类型错误。 voidActionScript3中可用 “*” 来表示任意类型。如果在脚本中这么做，则将丧失编译时类型检查，类型检查将在运行时进行。 functionActionScript3中的任何function都是一个Function对象。 当.net类库需要接收一个委托时，将一个function作为参数传递过去，系统会自动将其包装成一个委托。当.net类库接收到这个委托后，当.net类库内部调用这个委托时，系统会将.net传递的参数转换成相应的ActionScript3对象并传递给此Function对象并调用。如果参数不匹配，则会引发异常。因此，把function作为参数传递给.net时，还是需要注意函数参数和返回值的匹配。如下代码演示如何给UGUI的Button添加响应。 1234567var btn:Button = Button( GameObject.find(\"Button\").getComponent(Button)); btn.onClick.addListener( function()&#123; trace(\"Clicked!\"); &#125; ); ClassActionScript3中的Class,当被作为参数传递给.net时，系统将会将它转换成对应的System.Type对象。只有从.net导入的API类型才有此对应关系。如果不是从.net导入的类型，转换时会产生错误。","tags":[],"categories":[{"name":"1_beginuse","slug":"1-beginuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/"},{"name":"1_2useas3","slug":"1-beginuse/1-2useas3","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/1-2useas3/"}]},{"title":"API导出工具","date":"2018-03-20T06:55:49.000Z","path":"1-4-0-linkcodegenconfig-2018-03-20/","text":"API导出工具LinkCodeGenCLI.exe在SDK目录中的/linkcodegencli子目录下。这是一个控制台程序。可以接收如下参数:config=&lt;configfilename&gt;.xml 来指定一个配置文件。ActionScript3项目中，默认生成的配置文件是 genapi.config.xml。 执行bat/CreateUnityAPI.bat将会重新生成API文档，并生成Unity工程中的API注册代码。 主要配置节有：12345678&lt;appSettings&gt;&lt;!--配置SDK，代码文件等的路径--&gt;&lt;/appSettings&gt;&lt;includelibcode&gt;&lt;!--一同编译的类库代码--&gt;&lt;/includelibcode&gt;&lt;buildassemblys&gt;&lt;!--要导出API的程序集--&gt;&lt;/buildassemblys&gt;&lt;resolvepath&gt;&lt;!--依赖程序集的查找位置--&gt;&lt;/resolvepath&gt;&lt;skipcreatortypes&gt;&lt;!--指定已手工创建API的类型--&gt;&lt;/skipcreatortypes&gt;&lt;notcreatenamespace&gt;&lt;!--指定哪些命名空间的类型不会被导出--&gt;&lt;/notcreatenamespace&gt;&lt;notcreatetypes&gt;&lt;!--指定哪些类型不会被导出--&gt;&lt;/notcreatetypes&gt;&lt;notcreatemembers&gt;&lt;!--指定哪些类型成员不会被导出--&gt;&lt;/notcreatemembers&gt; appSettings配置各种文件的输出路径和输入路径。 csharpcodepath ActionScript3引擎要调用.net类库需要有对应的调用代码。每一个.net的Type,都会对应一个代码文件。指定这些文件的输出目录。 csharpcodenamespace 输出的API调用代码的命名空间. regfunctioncodefile 当ActionScript3引擎启动时需要注册前面生成的调用代码。这个文件包含了这些注册代码。 regfunctioncodenamespace 注册代码的命名空间 以上配置如果改动，则相应需要改动Unity工程中的ActionScript3引擎加载代码。如无必要保持默认即可 combiedcodefile 可以把csharpcodepath中配置的输出目录中的所有C#代码合并为一个文件。 sdkpath 指定SDK地址。默认值是auto。如果LinkCodeGenCLI.exe所在目录就在SDK目录的/linkcodegencli子目录中,则配置为auto就表示所在目录就在SDK目录中。 as3apipath 将.net类库转换为ActionScript3的代码。这些代码仅包含类型声明和调用函数的对应关系，FlashDevelop可读取这些代码作为智能提示。 as3libfile 将API编译成二进制字节码。由于API不会手工变动，因此编译一次以后直接加载即可。 约定：这个文件必须在ActionScript项目的lib目录中，并且文件名为as3unitylib.cswc。 如果缺少此文件，则编译会失败并提示。 includelibcode配置其他要预编译的ActionScript3代码。如果有些类库是ActionScript3代码编写的，并且不会频繁修改，则可以一起编译。默认包含SDK目录下的/as3corelib目录。123 &lt;includelibcode&gt; &lt;item value=\"$(sdkpath)\\as3corelib\"&gt;&lt;/item&gt;&lt;/includelibcode&gt; buildassemblys配置想要导出API的dll。每个assembly子节点配置一个dll。assembly子节点下还可以配置type节点，如果这么做了，那么只有配置的类型会被导出，否则将导出所有可以导出的类型。 例如:123456 &lt;buildassemblys&gt; &lt;assembly value=\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v3.5\\Profile\\Unity Full v3.5\\System.dll\"&gt; &lt;type definetype=\"type\" value=\"aa\"&gt;&lt;/type&gt;&lt;type definetype=\"namespace\" value=\"bb\"&gt;&lt;/type&gt; &lt;/assembly&gt; &lt;/buildassemblys&gt; 只有名字叫aa的类型或者命名空间为bb的类型才会被导出，因此实际上不会有任何类型被导出。 resolvepath配置dll的查找路径。当解析dll时，可能需要加载它依赖的dll,例如当加载ScriptAssemblies\\Assembly-CSharp.dll时，可能需要到UnityAssemblies下查找UnityEngine.CoreModule.dll等。在这里配置dll查找路径.如果有问题，还可以到Unity安装目录下去查找。 要定位Unity的dll,请到Unity的安装目录下查找。Unity工程的Library里面的dll有些读取时会引发BadImageFormatException异常。当发生这种情况时，请到Unity安装目录的/Editor/Data/Managed/目录下加载UnityEngine.dll, /Editor/Data/UnityExtensions/Unity/GUISystem/下加载UnityEngine.UI.dll。Unity2017 v2之后,Unity将UnityEngine.dll拆成了许多小dll,其中工程目录Library/UnityAssemblies中的UnityEngine.dll是无法被加载的。因此查找路径要注意顺序，先到安装目录下找，再到Library/UnityAssemblies中查找，否则可能会导致dll加载失败。 skipcreatortypes已经手工写过api的类型。由于某些类型比较特殊，需要特别对待以满足特殊需求，这些类型被在这里指明。当生成器遇到这些类型时，就不会为它们生成代码。 notcreatenamespace配置的命名空间下的全部类型都不会被导出。任何引用，继承到它们的方法，类型都不会被导出。 notcreatetypes配置的类型不会被导出。任何引用，继承到它们的方法，类型都不会被导出。 notcreatemembers配置的成员在遇到时会被跳过。Unity在运行时，某些类型的某些成员会不可用。为此，只能在导出api时跳过这些成员。在这里配置这些成员。 例如UnityEngine.Light.areaSize在编辑器状态下可用，但是发布时候确不可用。因此，必须配置这些成员以在导出API时跳过。","tags":[],"categories":[{"name":"1_beginuse","slug":"1-beginuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/"},{"name":"1_1configureproject","slug":"1-beginuse/1-1configureproject","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/1-1configureproject/"}]},{"title":"ActionScript3项目配置","date":"2018-03-20T03:34:55.000Z","path":"1-3-0-projectconfig-2018-03-20/","text":"ActionScript3项目目录结构如下 .├─── as3_unity├─── bat│ ├───CompileCode.bat│ └───CreateUnityAPI.bat├─── bin├─── lib│ └───as3unitylib.cswc├─── obj│ └───&lt;projectname&gt;Config.xml├─── src│ └───Main.as├─── application.xml├─── genapi.config.xml├─── ASRuntime_readme.txt└─── &lt;projectname&gt;.as3proj &lt;projectname&gt;.as3proj项目配置文件。其中配置了SDK的路径:1234&lt;output&gt; ... &lt;movie preferredSDK=\"F:\\ASTool_UnityTest\\publish\\SDK1.0.0\" /&gt;&lt;/output&gt; 工程中的源码路径和类库路径12345678&lt;classpaths&gt; &lt;!--src code--&gt; &lt;class path=\"src\" /&gt; &lt;!--api code--&gt; &lt;class path=\"F:\\ASTool_UnityTest\\publish\\SDK1.0.0\\as3_commapi\\api\" /&gt; &lt;class path=\"F:\\ASTool_UnityTest\\publish\\SDK1.0.0\\as3_commapi\\sharpapi\" /&gt; &lt;class path=\"as3_unity\" /&gt;&lt;/classpaths&gt; bat包含了几个有用的bat文件。 CompileCode.bat 如果没有安装FlashDevelop或者没有安装JAVA,则运行此bat可以编译代码并发布到Unity工程。 CreateUnityAPI.bat 运行此bat可以重新创建Unity API。 lib/as3unitylib.cswc当创建Unity API时会自动编译生成此文件，这是一个预编译的ActionScript3 API字节码文件。当编译ActionScript3工程时，编译器会加载此文件对代码进行类型检查等操作。 &lt;projectname&gt;Config.xml传递给编译器的工程配置文件。如果使用FlashDevelop,则每次编译时FlashDevelop会自动生成这个文件。但是，如果不使用FlashDevelop,则必须手工编辑此配置文件，然后用 bat/CompileCode.bat 进行编译。当然，第一次生成ActionScript3工程时，也会自动创建好这个文件，如果确保脚本代码都写在src目录中，则无需对此进行修改。1234567&lt;source-path append=\"true\"&gt; &lt;path-element&gt;F:\\ASTool_UnityTest\\AS3HotFixU47\\HotFixProj\\src&lt;/path-element&gt; &lt;path-element&gt;F:\\ASTool_UnityTest\\publish\\SDK1.0.0\\as3_commapi\\api&lt;/path-element&gt; &lt;path-element&gt;F:\\ASTool_UnityTest\\publish\\SDK1.0.0\\as3_commapi\\sharpapi&lt;/path-element&gt; &lt;path-element&gt;F:\\ASTool_UnityTest\\AS3HotFixU47\\HotFixProj\\as3_unity&lt;/path-element&gt; &lt;path-element&gt;D:\\Program Files (x86)\\FlashDevelop\\Library\\AS3\\classes&lt;/path-element&gt;&lt;/source-path&gt; src源代码目录。 genapi.config.xmlAPI代码生成器的详细配置。这个工具可用来创建.net类库和ActionScript3之间交互的API。API配置说明","tags":[],"categories":[{"name":"1_beginuse","slug":"1-beginuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/"},{"name":"1_1configureproject","slug":"1-beginuse/1-1configureproject","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/1-1configureproject/"}]},{"title":"创建Unity工程和脚本工程","date":"2018-03-19T11:22:04.000Z","path":"1-2-0-createunityproject-2018-03-19/","text":"先下载最新的发布包，并解压。解压后的目录内容如下: .├─── SDK[X.X.X]└─── UnityPackage └───AS3RuntimeForUnity.unitypackage SDK[X.X.X] 是一个自定义的 AIRSDK.可被FlashDevelop识别并加载，使用它来进行代码的编译和发布。 UnityPackage 内含Unity插件包 “AS3RuntimeForUnity.unitypackage”。 项目创建步骤: 先创建一个Unity工程。然后导入UnityPackage内的Unity插件包。 点击菜单 ASRuntime/Create ActionScript3 FlashDevelop HotFixProj。 根据提示先定位SDK的位置。 然后根据提示创建AS3热更新项目。项目创建完成后，会根据默认配置生成Unity的API。 ActionScript3项目要求创建在一个空白的文件夹中。 项目测试： 在Unity工程中，打开测试场景”Assets/HotFixDemoScene1.scene”。 在刚才生成的ActionScript3工程目录中，用FlashDevelop打开.as3proj 工程文件。 在AS3工程中修改代码 点击FlashDevelop的编译按钮,进行编译 回到Unity工程，点击播放，即可看到修改的结果。 下面是一个gif动态示意图，如果没有显示，请稍等片刻","tags":[],"categories":[{"name":"1_beginuse","slug":"1-beginuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/"},{"name":"1_1configureproject","slug":"1-beginuse/1-1configureproject","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/1-1configureproject/"}]},{"title":"概述","date":"2018-03-19T11:21:45.000Z","path":"1-1-0-overview-2018-03-19/","text":"什么是Apple Juice?Apple Juice是一个纯 .net2.0 代码实现的ActionScript3引擎。设计之初就是为了能够离线的编译ActionScript3代码，并且在任意有.net2.0运行环境的场合执行。目前，最典型的应用场合就是在Unity3D的应用中执行ActionScrpt3脚本。 什么是ActionScript3ActionScript3就是事实上的ECMAScript4的唯一实现。主要运行于Adobe Flash Player和Adobe AIR环境。是一门面向对象的编程语言，同时又兼容JS的动态语言特性。我们用.net2.0 实现了一个ActionScript3引擎，可以在更多的环境下执行ActionScript3脚本。这里是ActionScript3的语言参考 为什么要在Unity中运行Unity是一个跨平台的3D游戏引擎。它使用C#语言进行开发工作。本脚本引擎提供了让Unity执行ActionScript3代码的能力。并且不受其他环境因素限制，只要Unity发布的App可以运行，则ActionScript3就可以运行。 工作原理Apple Juice提供了如下功能： ActionScript3编译器。它离线编译您的ActionScript3代码，并生成一个二进制字节码文件。 除了极个别特例外，所有ActionScript3语法都有支持。包括类型，接口，数据类型，编译时期强类型检查,dynamic动态类型，prototype原型链扩展等等。以下为明确不支持的语法特性: namespace ActionScript3中，命名空间可用于控制对类中的一组属性和方法的访问。本脚本系统仅支持public protected private 等内置访问修饰符，自定义namespace功能不支持。 ECMAScript for XML(E4X) 内嵌XML以及E4X相关操作符等功能明确不支持。 Apple Juice ActionScript3脚本可以调用其他.net类库提供的公开功能。因此Unity的API也可被调用。由于ActionScript3本身拥有完整的编译时期类型检查和完整的类型继承系统，因此.net类库的结构可以被大部分完整的映射到ActionScript3中。Apple Juice提供了API代码生成工具，可以自动的将需要的API生成到ActionScript3工程。 一旦API生成后，就可以在ActionScript3脚本中对Unity类库进行操作。编译器在编译时能做出类型检查，提前发现代码中的错误。强类型系统能提高脚本的执行性能。一旦编译通过，编译器会生成一个二进制字节码文件。这个文件可以直接部署到Unity工程中，也可以部署到网络上按需要下载。 ActionScript3运行时。是一个纯C#编写的类库，可以直接在Unity项目中使用。Unity启动时，先创建ActionScript3运行时实例，再注册上一步生成的API,然后加载编译好的二进制字节码，即可执行脚本。 这个二进制字节码可以从任意地方加载，比如从网络下载，等等 下载可以在这里下载最新的运行时和Unity插件。https://github.com/asheigithub/apple-juice-actionscript 需要的环境要运行Apple Juice很简单，不过在用它编写Unity脚本前，要注意最好有以下环境: FlashDevelop 推荐的ActionScript3 IDE. JRE FlashDevelop正常编译需要JRE支持。 .net framework2.0以上。目前的Windows版本应该都是自带的。 Windows. 目前Apple Juice的Unity编译工具流程时假设在Windows上运行的 Unity 4.X以上版本推荐5.X以上版本。 插件中的Demo场景是搭建于Unity5.6的，但是Apple Juice ActionScript3引擎确实能在Unity 4.7上正常运行。 其中JAVA和FlashDevelop不是必须的，如果不安装IDE,则您需要用其他任意文本编辑器来编写代码，并手动执行一个编译的批处理命令来进行编译和发布。但是，FlashDevelop可以提供如智能感知，自动补全，错误提示，代码格式化等等方便的功能。为了方便起见，建议安装JRE和FlashDevelop。","tags":[],"categories":[{"name":"1_beginuse","slug":"1-beginuse","permalink":"https://asheigithub.github.io/apple-juice-actionscript/doc_cn/categories/1-beginuse/"}]},{"title":"欢迎","date":"2018-03-16T10:41:21.000Z","path":"index-2018-03-16/","text":"欢迎使用 Apple Juice这是一个纯 .net2.0实现的ActionScript3 编译器和虚拟机。 支持除了 namespace 和 with 和 E4X XML操作外的一切actionscript3语法特性。 可以将actionscript3代码编译为字节码，然后加载并动态执行。VM由纯C# 2.0代码实现，可以直接让Unity来读取并执行生成的字节码，就是可用Unity完成热更新操作。编译器部分实现了完整的编译期类型检查。并且有完整的错误提示。已经和FlashDevelop完成了集成，可以直接在FlashDevelop中开发并一键编译发布到Unity。Unity的API或者自己开发的C# API提供了工具直接转换为actionscript api文件和对接代码，并且直接注册到FlashDevelop工程中。 特色 对.net的结构体有特殊优化。在脚本中只要在方法的局部变量中使用，可以任意的new而不会导致gc.因此使用UnityEngine.Vector3之类类型时，可以放心使用。 对导出的类型有特殊优化。只要在方法的局部变量中使用，则脚本本身不产生额外的对象分配。 实现操作符重载。导出的对象如果有操作符重载，则在脚本中同样可以使用。如下代码是完全合法的。 1cube.transform.localPosition += v * Time.deltaTime; 可以使用yield语句返回一个IEnumerator,然后用Iterator包装为.net的IEnumerator接口。所以可以直接在脚本中写Unity的协程。如如下代码所示: 12345678910111213141516171819var mono:MonoBehaviour = GameObject.find(\"AS3Player\").getComponent(MonoBehaviour) as MonoBehaviour;trace(mono.name);mono.startCoroutine( Iterator( ( function() &#123; trace(\"a\",Time.frameCount); yield return 1; trace(\"b\",Time.frameCount); yield return 2; trace(\"c\",Time.frameCount); yield return 3; &#125; )())); 自动将.net 委托对应到ActionScript3的function对象。例如: 1234567891011var btn:Button = Button( GameObject.find(\"Button\").getComponent(Button)); btn.onClick.addListener( onclick );btn.onClick.addListener( function() &#123; trace(\"hahaha\",this); &#125;); 自动处理.net 类库中的 out ref类型的参数。这样的方法也可自动导出。例如 long.TryParse: 12345678910/*** System.Int64.TryParse*parameters:* s : System.String* result : (Out)System.Int64*return:* System.Boolean*/[native,static_system_Int64_tryParse];public static function tryParse(s:String,result:Int64,refout:as3runtime.RefOutStore):Boolean; 可以在ActionScript3脚本中继承.net类库。如以下脚本，在脚本中自定义了一个MonoBehaviour,然后创建100个物体，并将此对象挂在这些物体上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var isstop:Boolean = false;//Define a subclass of MonoBehaviourclass MyB extends MonoBehaviour&#123; private var v:Vector3; function Awake() &#123; v = new Vector3(Random.range( -5, 5), Random.range( -5, 5), Random.range( -5, 5)); v.normalize(); &#125; function Update() &#123; if (isstop) return; var vv:Vector3 = new Vector3(4, 5, 6); gameObject.transform.localPosition += v * Time.deltaTime; var p:Vector3 = gameObject.transform.localPosition; if (p.x &lt;-5 || p.y &lt; -5 || p.z &lt; -5 || p.x &gt; 5 || p.y &gt; 5 || p.z &gt; 5) &#123; v =-v; &#125; &#125;&#125;var cube:UObject = GameObject.find(\"Cube\");for (var i:int = 0; i &lt; 100; i++) &#123; var c2:GameObject = GameObject.createPrimitive( PrimitiveType.Cube); //UObject.instantiate__(cube) as GameObject; MeshRenderer( c2.getComponent(MeshRenderer)).material = MeshRenderer( GameObject( cube).getComponent(MeshRenderer)).material; c2.transform.position = new Vector3( Random.range(-5,5),Random.range(0,5),Random.range(-5,5) ); //Mount the MonoBehaviour just defined on the object c2.addComponent(MyB);&#125;var btn:Button = Button( GameObject.find(\"Button\").getComponent(Button)); btn.onClick.addListener( function() &#123; isstop = !isstop; trace(\"isstop?\" , isstop); Text( GameObject.find(\"Canvas/Text\").getComponent(Text)).text = \"isstop?\" + isstop +\"我在AS3中热更\"; &#125;); 完整的编译期类型检查。脚本有完整的编译时类型检查，利于错误排查。 完全实现的面向对象支持。完整支持类继承和接口。 FlashDevelop IDE支持。可以完全利用IDE的智能提示，编译错误也可在IDE中得到反馈。可在IDE中直接编译热更新代码成到Unity项目 api全自动导出 自动将.net类库导出给脚本使用。并且保留有原始类型信息。例如UnityEngine.Avatar导出后的api形式为:12345678910111213141516171819202122232425262728293031323334353637package unityengine &#123; /** * Sealed * UnityEngine.Avatar */ [no_constructor] [link_system] public final class Avatar extends UObject &#123; [creator]; [native,unityengine_Avatar_creator]; private static function _creator(type:Class):*; [native,$$_noctorclass]; public function Avatar(); //*********公共方法******* /** * UnityEngine.Avatar.get_isValid *return: * System.Boolean */ [native,unityengine_Avatar_get_isValid] public final function get isValid():Boolean; /** * UnityEngine.Avatar.get_isHuman *return: * System.Boolean */ [native,unityengine_Avatar_get_isHuman] public final function get isHuman():Boolean; &#125; &#125; IDE能提供智能感知提示。 自动导出的API为actionscript3风格。比如UnityEngine.UI.Button 将被导出为 unityengine.ui.Button 能将.net 类库中的类型包含继承关系和接口实现关系的导出。例如，UnityEngine.MeshRenderer 继承自 UnityEngine.Renderer 。那么导出后的as3类型也会保持以上的关系。","tags":[],"categories":[]}]}